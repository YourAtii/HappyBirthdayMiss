<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Happy Birthday Miss</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #111; overflow: hidden; }
    /* Canvas is sized via JS for HiDPI crispness */
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script>
  // ===== Canvas + HiDPI setup =====
  const c = document.getElementById("c");
  const ctx = c.getContext("2d", { alpha: false });

  let cssW = window.innerWidth;
  let cssH = window.innerHeight;
  let dpr  = Math.max(1, Math.min(window.devicePixelRatio || 1, 2)); // cap for performance
  function sizeCanvas() {
    cssW = window.innerWidth;
    cssH = window.innerHeight;
    dpr  = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    c.width  = Math.floor(cssW * dpr);
    c.height = Math.floor(cssH * dpr);
    // normalize drawing to CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    w = cssW; h = cssH; hw = w/2; hh = h/2;
    ctx.font = opts.charSize + "px Verdana";
  }

  let w = cssW, h = cssH, hw = w/2, hh = h/2;

  // ===== Options (text bigger + spacing) =====
  const opts = {
    strings: ["HAPPY", "BIRTHDAY!", "Miss"],
    charSize: 44,                 // bigger text
    charSpacing: 44,
    lineHeight: 56,
    cx: cssW/2, cy: cssH/2,

    fireworkPrevPoints: 10, fireworkBaseLineWidth: 5, fireworkAddedLineWidth: 8,
    fireworkSpawnTime: 200, fireworkBaseReachTime: 30, fireworkAddedReachTime: 30,
    fireworkCircleBaseSize: 20, fireworkCircleAddedSize: 10,
    fireworkCircleBaseTime: 30, fireworkCircleAddedTime: 30,
    fireworkCircleFadeBaseTime: 10, fireworkCircleFadeAddedTime: 5,
    fireworkBaseShards: 5, fireworkAddedShards: 5,
    fireworkShardPrevPoints: 3, fireworkShardBaseVel: 4, fireworkShardAddedVel: 2,
    fireworkShardBaseSize: 3, fireworkShardAddedSize: 3,
    gravity: 0.1, upFlow: -0.1,
    letterContemplatingWaitTime: 360,

    balloonSpawnTime: 20, balloonBaseInflateTime: 10, balloonAddedInflateTime: 10,
    balloonBaseSize: 20, balloonAddedSize: 20,
    balloonBaseVel: 0.4, balloonAddedVel: 0.4,
    balloonBaseRadian: -(Math.PI/2 - 0.5), balloonAddedRadian: -1
  };

  // ===== Speed profile =====
  // Laptop/Desktop ≈ +25% faster; Mobile ≈ 10% slower
  const IS_MOBILE = /Mobi|Android/i.test(navigator.userAgent);
  const speedFactor = IS_MOBILE ? 0.90 : 1.25;

  (function applySpeed(f) {
    // Shorter times = faster, so divide by f
    const timeKeys = [
      "fireworkSpawnTime","fireworkBaseReachTime","fireworkAddedReachTime",
      "fireworkCircleBaseTime","fireworkCircleAddedTime",
      "fireworkCircleFadeBaseTime","fireworkCircleFadeAddedTime",
      "letterContemplatingWaitTime",
      "balloonSpawnTime","balloonBaseInflateTime","balloonAddedInflateTime"
    ];
    timeKeys.forEach(k => opts[k] = Math.max(1, Math.round(opts[k] / f)));

    // Higher velocities/gravity = faster, so multiply by f
    const velKeys = [
      "balloonBaseVel","balloonAddedVel",
      "fireworkShardBaseVel","fireworkShardAddedVel",
      "gravity"
    ];
    velKeys.forEach(k => opts[k] *= f);

    // Upflow should scale with f too
    opts.upFlow *= f;
  })(speedFactor);

  // ===== Derived + misc =====
  const calc = { totalWidth: opts.charSpacing * Math.max(opts.strings[0].length, opts.strings[1].length) };
  const Tau = Math.PI * 2, TauQuarter = Tau / 4;
  const letters = [];

  // ===== Image (robust loading for GitHub Pages) =====
  // Use same-folder "Mam.png" or replace with absolute URL.
  const img = new Image();
  // Uncomment the next line if you host the image on another origin:
  // img.crossOrigin = "anonymous";
  img.src = "Mam.png";

  let sprite = null;
  let imgReady = false;
  let t0 = performance.now();
  let imgYBase = -210;   // image vertical position
  let baseRadius = 95;   // circle radius (slightly bigger to match bigger text)

  // Decode -> ImageBitmap for smooth first draw
  (async () => {
    try {
      if (img.decode) await img.decode();
      const bmp = await createImageBitmap(img);
      sprite = bmp; imgReady = true; t0 = performance.now();
    } catch (e) {
      // Fallbacks
      img.onload = async () => {
        try {
          const bmp = await createImageBitmap(img);
          sprite = bmp; imgReady = true; t0 = performance.now();
        } catch { imgReady = true; } // draw raw <img> if bitmap fails
      };
      img.onerror = () => { imgReady = false; }; // no image
    }
  })();

  // ===== Letter / Fireworks / Balloons with soft glow on text =====
  function Letter(char, x, y) {
    this.char = char; this.x = x; this.y = y;
    this.dx = -ctx.measureText(char).width / 2;
    this.dy = +opts.charSize / 2;
    this.fireworkDy = this.y - hh;
    let hue = (x / calc.totalWidth) * 360;
    this.color = `hsl(${hue},80%,50%)`;
    this.lightAlphaColor = `hsla(${hue},80%,light%,alp)`;
    this.lightColor = `hsl(${hue},80%,light%)`;
    this.alphaColor = `hsla(${hue},80%,50%,alp)`;
    this.reset();
  }
  Letter.prototype.reset = function () {
    this.phase = "firework"; this.tick = 0; this.spawned = false;
    this.spawningTime = (opts.fireworkSpawnTime * Math.random()) | 0;
    this.reachTime = (opts.fireworkBaseReachTime + opts.fireworkAddedReachTime * Math.random()) | 0;
    this.lineWidth = opts.fireworkBaseLineWidth + opts.fireworkAddedLineWidth * Math.random();
    this.prevPoints = [[0, hh, 0]];
  };

  function drawTextGlow(letter, x, y, glowStrength = 12) {
    ctx.save();
    ctx.shadowColor = letter.lightAlphaColor.replace("light", 100).replace("alp", 0.45);
    ctx.shadowBlur = glowStrength;
    ctx.fillStyle = letter.lightColor.replace("light", 75);
    ctx.fillText(letter.char, x + letter.dx, y + letter.dy);
    ctx.restore();
  }

  Letter.prototype.step = function () {
    if (this.phase === "firework") {
      if (!this.spawned) {
        if (++this.tick >= this.spawningTime) { this.tick = 0; this.spawned = true; }
      } else {
        ++this.tick;
        let p = this.tick / this.reachTime,
            a = Math.sin(p * TauQuarter),
            x = p * this.x,
            y = hh + a * this.fireworkDy;

        if (this.prevPoints.length > opts.fireworkPrevPoints) this.prevPoints.shift();
        this.prevPoints.push([x, y, p * this.lineWidth]);

        let lwp = 1 / (this.prevPoints.length - 1);
        for (let i = 1; i < this.prevPoints.length; ++i) {
          let pt = this.prevPoints[i], pt2 = this.prevPoints[i - 1];
          ctx.strokeStyle = this.alphaColor.replace("alp", i / this.prevPoints.length);
          ctx.lineWidth = pt[2] * lwp * i;
          ctx.beginPath(); ctx.moveTo(pt[0], pt[1]); ctx.lineTo(pt2[0], pt2[1]); ctx.stroke();
        }

        if (this.tick >= this.reachTime) {
          this.phase = "contemplate";
          this.circleFinalSize =
            opts.fireworkCircleBaseSize + opts.fireworkCircleAddedSize * Math.random();
          this.circleCompleteTime =
            (opts.fireworkCircleBaseTime + opts.fireworkCircleAddedTime * Math.random()) | 0;
          this.circleCreating = true; this.circleFading = false;
          this.circleFadeTime =
            (opts.fireworkCircleFadeBaseTime + opts.fireworkCircleFadeAddedTime * Math.random()) | 0;
          this.tick = 0; this.tick2 = 0;

          this.shards = [];
          let shardCount = (opts.fireworkBaseShards + opts.fireworkAddedShards * Math.random()) | 0,
              ang = Tau / shardCount, cos = Math.cos(ang), sin = Math.sin(ang),
              xx = 1, yy = 0;
          for (let i = 0; i < shardCount; ++i) {
            let x1 = xx; xx = xx * cos - yy * sin; yy = yy * cos + x1 * sin;
            this.shards.push(new Shard(this.x, this.y, xx, yy, this.alphaColor));
          }
        }
      }
    } else if (this.phase === "contemplate") {
      ++this.tick;
      if (this.circleCreating) {
        ++this.tick2;
        let p = this.tick2 / this.circleCompleteTime,
            a = -Math.cos(p * Math.PI) / 2 + 0.5;
        ctx.beginPath();
        ctx.fillStyle = this.lightAlphaColor.replace("light", 50 + 50 * p).replace("alp", p);
        ctx.arc(this.x, this.y, a * this.circleFinalSize, 0, Tau);
        ctx.fill();
        if (this.tick2 > this.circleCompleteTime) { this.tick2 = 0; this.circleCreating = false; this.circleFading = true; }
      } else if (this.circleFading) {
        drawTextGlow(this, this.x, this.y, 14);
        ++this.tick2;
        let p = this.tick2 / this.circleFadeTime,
            a = -Math.cos(p * Math.PI) / 2 + 0.5;
        ctx.beginPath();
        ctx.fillStyle = this.lightAlphaColor.replace("light", 100).replace("alp", 1 - a);
        ctx.arc(this.x, this.y, this.circleFinalSize, 0, Tau);
        ctx.fill();
        if (this.tick2 >= this.circleFadeTime) this.circleFading = false;
      } else {
        drawTextGlow(this, this.x, this.y, 12);
      }

      for (let i = 0; i < this.shards.length; ++i) {
        this.shards[i].step();
        if (!this.shards[i].alive) { this.shards.splice(i, 1); --i; }
      }

      if (this.tick > opts.letterContemplatingWaitTime) {
        this.phase = "balloon";
        this.tick = 0; this.spawning = true;
        this.spawnTime = (opts.balloonSpawnTime * Math.random()) | 0;
        this.inflating = false;
        this.inflateTime = (opts.balloonBaseInflateTime + opts.balloonAddedInflateTime * Math.random()) | 0;
        this.size = (opts.balloonBaseSize + opts.balloonAddedSize * Math.random()) | 0;
        let rad = opts.balloonBaseRadian + opts.balloonAddedRadian * Math.random(),
            vel = opts.balloonBaseVel + opts.balloonAddedVel * Math.random();
        this.vx = Math.cos(rad) * vel; this.vy = Math.sin(rad) * vel;
      }
    } else if (this.phase === "balloon") {
      ctx.strokeStyle = this.lightColor.replace("light", 80);
      if (this.spawning) {
        ++this.tick;
        drawTextGlow(this, this.x, this.y, 12);
        if (this.tick >= this.spawnTime) { this.tick = 0; this.spawning = false; this.inflating = true; }
      } else if (this.inflating) {
        ++this.tick;
        let p = this.tick / this.inflateTime, x = (this.cx = this.x), y = (this.cy = this.y - this.size * p);
        ctx.fillStyle = this.alphaColor.replace("alp", p);
        ctx.beginPath(); generateBalloonPath(x, y, this.size * p); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, this.y); ctx.stroke();
        drawTextGlow(this, this.x, this.y, 12);
        if (this.tick >= this.inflateTime) { this.tick = 0; this.inflating = false; }
      } else {
        this.cx += this.vx; this.cy += this.vy += opts.upFlow;
        ctx.fillStyle = this.color;
        ctx.beginPath(); generateBalloonPath(this.cx, this.cy, this.size); ctx.fill();
        ctx.beginPath(); ctx.moveTo(this.cx, this.cy); ctx.lineTo(this.cx, this.cy + this.size); ctx.stroke();
        drawTextGlow(this, this.cx, this.cy + this.size, 12);
        if (this.cy + this.size < -hh || this.cx < -hw || this.cy > hw) this.phase = "done";
      }
    }
  };

  function Shard(x, y, vx, vy, color) {
    let vel = opts.fireworkShardBaseVel + opts.fireworkShardAddedVel * Math.random();
    this.vx = vx * vel; this.vy = vy * vel;
    this.x = x; this.y = y;
    this.prevPoints = [[x, y]];
    this.color = color; this.alive = true;
    this.size = opts.fireworkShardBaseSize + opts.fireworkShardAddedSize * Math.random();
  }
  Shard.prototype.step = function () {
    this.x += this.vx; this.y += this.vy += opts.gravity;
    if (this.prevPoints.length > opts.fireworkShardPrevPoints) this.prevPoints.shift();
    this.prevPoints.push([this.x, this.y]);
    let lwp = this.size / this.prevPoints.length;
    for (let k = 0; k < this.prevPoints.length - 1; ++k) {
      let p = this.prevPoints[k], p2 = this.prevPoints[k + 1];
      ctx.strokeStyle = this.color.replace("alp", k / this.prevPoints.length);
      ctx.lineWidth = k * lwp;
      ctx.beginPath(); ctx.moveTo(p[0], p[1]); ctx.lineTo(p2[0], p2[1]); ctx.stroke();
    }
    if (this.prevPoints[0][1] > hh) this.alive = false;
  };

  function generateBalloonPath(x, y, size) {
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x - size/2, y - size/2, x - size/4, y - size, x, y - size);
    ctx.bezierCurveTo(x + size/4, y - size, x + size/2, y - size/2, x, y);
  }

  // ===== Main loop =====
  function anim() {
    requestAnimationFrame(anim);

    // background
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, w, h);

    // center origin
    ctx.save();
    ctx.translate(hw, hh);

    // Circular image (clipped), no glow/ring
    if (imgReady) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      const t = (performance.now() - t0) / 1000;
      const scalePulse = 1 + 0.04 * Math.sin(t * 2.0);
      const bobY       = 10 * Math.sin(t * 1.5);
      const r = baseRadius * scalePulse;

      ctx.save();
      ctx.beginPath();
      ctx.arc(0, imgYBase + bobY, r, 0, Tau);
      ctx.closePath();
      ctx.clip();

      const source = sprite || img; // draw bitmap if ready, else the image element
      const sw = source.naturalWidth || source.width || 0;
      const sh = source.naturalHeight || source.height || 0;
      if (sw && sh) {
        const side = Math.min(sw, sh);
        const sx = (sw - side) / 2;
        const sy = (sh - side) / 2;
        const d  = r * 2;
        ctx.drawImage(source, sx, sy, side, side, -r, imgYBase + bobY - r, d, d);
      }
      ctx.restore();
    }

    // letters / fireworks / balloons
    let done = true;
    for (let l = 0; l < letters.length; ++l) {
      letters[l].step();
      if (letters[l].phase !== "done") done = false;
    }
    ctx.restore();

    if (done) for (let l = 0; l < letters.length; ++l) letters[l].reset();
  }

  // Build letters
  function buildLetters() {
    letters.length = 0;
    ctx.font = opts.charSize + "px Verdana";
    for (let i = 0; i < opts.strings.length; ++i) {
      const row = opts.strings[i];
      for (let j = 0; j < row.length; ++j) {
        letters.push(
          new Letter(
            row[j],
            j * opts.charSpacing + opts.charSpacing/2 - (row.length * opts.charSpacing) / 2,
            i * opts.lineHeight + opts.lineHeight/2 - (opts.strings.length * opts.lineHeight) / 2
          )
        );
      }
    }
  }

  sizeCanvas();
  buildLetters();
  anim();

  // Resize handling
  window.addEventListener("resize", () => {
    sizeCanvas();
    buildLetters(); // keep text centered and crisp
  }, { passive: true });
  </script>
</body>
</html>
